// Package cborgen provides a fast Marshaler implementation for CBOR backed by `go-ipld-cbor` package
// and marshaling/unmarshaling code generated by github.com/daotl/cbor-gen package.

package cborgen

import (
	"bytes"
	"errors"
	"io"
	"strings"

	"github.com/ipfs/go-ipld-cbor/encoding"
	"github.com/polydawn/refmt/obj/atlas"

	"github.com/daotl/go-marsha"
)

var (
	ErrNotCBORStructPtr      = errors.New("not a cbor.StructPtr")
	ErrNotCBORStructSlicePtr = errors.New("not a cbor.StructSlicePtr")
	ErrTypeNotMatch          = errors.New("model type does not match")
)

var (
	emptyAtlas  = atlas.MustBuild()
	marshaler   = encoding.NewPooledMarshaller(emptyAtlas)
	unmarshaler = encoding.NewPooledUnmarshaller(emptyAtlas)
)

type StructPtr interface {
	marsha.StructPtr

	// MarshalCBOR should be generated by `github.com/daotl/cbor-gen` package.
	MarshalCBOR(w io.Writer) error

	// UnmarshalCBOR should be generated by `github.com/daotl/cbor-gen` package.
	UnmarshalCBOR(r io.Reader) error
}

type StructSlicePtr interface {
	marsha.StructSlicePtr

	// NewStruct should return an empty marsha.Struct.
	NewStruct() marsha.Struct

	// Append should append `p.Val()` to the `StructSlice` this `StructSlicePtr` points to.
	Append(p StructPtr)
}

// CBORGenMarshaler is a fast Marshaler implementation for CBOR backed by `go-ipld-cbor` package
// and marshaling/unmarshaling code generated by github.com/daotl/cbor-gen package.
type CBORGenMarshaler struct{}

var _ marsha.Marshaler = (*CBORGenMarshaler)(nil)

// New creates a CBORGenMarshaler.
func New() *CBORGenMarshaler {
	return &CBORGenMarshaler{}
}

func (m *CBORGenMarshaler) MarshalPrimitive(p interface{}) ([]byte, error) {
	return m.marshal(p)
}

func (m *CBORGenMarshaler) UnmarshalPrimitive(bin []byte, p interface{}) error {
	return m.unmarshal(bytes.NewReader(bin), p)
}

func (m *CBORGenMarshaler) MarshalStruct(p marsha.StructPtr) ([]byte, error) {
	cbp, ok := p.(StructPtr)
	if !ok {
		return nil, ErrNotCBORStructPtr
	}
	return m.marshal(cbp)
}

func (m *CBORGenMarshaler) UnmarshalStruct(bin []byte, p marsha.StructPtr) error {
	cbp, ok := p.(StructPtr)
	if !ok {
		return ErrNotCBORStructPtr
	}
	return m.unmarshal(bytes.NewReader(bin), cbp)
}

func (m *CBORGenMarshaler) MarshalStructSlice(p marsha.StructSlicePtr) (bin []byte, err error) {
	cbp, ok := p.(StructSlicePtr)
	if !ok {
		return nil, ErrNotCBORStructSlicePtr
	}

	bins := make([][]byte, len(p.Val()))
	l := 0
	for i, s := range cbp.Val() {
		if bins[i], err = m.MarshalStruct(s.Ptr()); err != nil {
			return nil, err
		}
		l += len(bins[i])
	}

	//binH := cbg.CborEncodeMajorType(cbg.MajArray, uint64(len(p.Val())))
	bin = make([]byte, 0 /*len(binH)+*/, l)
	//bin = append(bin, binH...)
	for _, b := range bins {
		bin = append(bin, b...)
	}
	return bin, nil
}

func (m *CBORGenMarshaler) UnmarshalStructSlice(bin []byte, p marsha.StructSlicePtr) error {
	cbp, ok := p.(StructSlicePtr)
	if !ok {
		return ErrNotCBORStructSlicePtr
	}

	r := bytes.NewReader(bin)
	for {
		s := cbp.NewStruct().Ptr().(StructPtr)
		if err := m.unmarshal(r, s); err != nil {
			if err == ErrTypeNotMatch {
				return err
			}
			break
		}
		cbp.Append(s)
	}
	return nil
}

func (m *CBORGenMarshaler) marshal(p interface{}) ([]byte, error) {
	bin, err := marshaler.Marshal(p)
	if err != nil {
		panic(err)
	}
	return bin, nil
}

func (m *CBORGenMarshaler) unmarshal(r io.Reader, p interface{}) error {
	if err := unmarshaler.Decode(r, p); err != nil {
		estr := err.Error()
		if strings.Contains(estr, "wrong type") {
			return ErrTypeNotMatch
		} else if strings.Contains(estr, "EOF") {
			return err
		} else {
			panic("unexpected error in unmarshalling")
		}
	}
	return nil
}
