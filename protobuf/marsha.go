// Package protobuf provides a Marsha implementation for Protocol Buffers backed by `*.pb.go`
// files pre-generated by `protoc`.
package protobuf

import (
	"errors"
	"io"
	"runtime"

	"google.golang.org/protobuf/proto"

	"github.com/daotl/go-marsha"
)

var (
	ErrNotPBStructPtr = errors.New("not a protobuf.StructPtr")
	ErrWrongPBType    = errors.New("wrong protocol buffers type")
)

// Struct implementations should embed their corresponding `proto.Message`s by pointer.
type Struct interface {
	proto.Message
}

type StructPtr interface {
	marsha.Struct

	// EmptyPB should return an empty corresponding `proto.Message`.
	EmptyPB() proto.Message

	// LoadPB should load data from `m` into the Struct this StructPtr points to.
	LoadPB(m proto.Message) error

	// PB should return a corresponding `proto.Message` filled with data of the Struct this StructPtr points to.
	PB() proto.Message
}

// Marsha is a `marsha.Marsha` implementation for Protocol Buffers backed by `*.pb.go` files
// pre-generated by `protoc`.
// Only `MarshalStruct` and `UnmarshalStruct` are supported by this implementation because of the
// limitation of Protocol Buffers.
type Marsha struct{}

var _ marsha.Marsha = (*Marsha)(nil)

// New creates a Marsha.
func New() *Marsha {
	return &Marsha{}
}

// Not implemented
func (m *Marsha) MarshalPrimitive(_ interface{}) ([]byte, error) {
	return nil, marsha.ErrUnimplemented
}

// Not implemented
func (m *Marsha) UnmarshalPrimitive(_ []byte, _ interface{}) error {
	return marsha.ErrUnimplemented
}

func (m *Marsha) MarshalStruct(p marsha.StructPtr) ([]byte, error) {
	pbp, ok := p.(StructPtr)
	if !ok {
		return nil, ErrNotPBStructPtr
	}
	return proto.Marshal(pbp.PB())
}

func (m *Marsha) UnmarshalStruct(bin []byte, p marsha.StructPtr) (err error) {
	// Recover if type assertion in LoadPB fails
	defer func() {
		if r := recover(); r != nil {
			switch e := r.(type) {
			case *runtime.TypeAssertionError:
				err = ErrWrongPBType
			case error:
				err = e
			case string:
				err = errors.New(e)
			default:
				err = errors.New("unknown panic")
			}
		}
	}()

	pbp, ok := p.(StructPtr)
	if !ok {
		return ErrNotPBStructPtr
	}
	pb := pbp.EmptyPB()
	err = proto.Unmarshal(bin, pb)
	if err == nil {
		err = pbp.LoadPB(pb)
	}
	return
}

// Not implemented
func (m *Marsha) MarshalStructSlice(_ marsha.StructSlicePtr) ([]byte, error) {
	return nil, marsha.ErrUnimplemented
}

// Not implemented
func (m *Marsha) UnmarshalStructSlice(_ []byte, _ marsha.StructSlicePtr) error {
	return marsha.ErrUnimplemented
}

// Not implemented
func (m *Marsha) NewEncoder(_ io.Writer) marsha.Encoder {
	panic(marsha.ErrUnimplemented)
}

// Not implemented
func (m *Marsha) NewDecoder(_ io.Reader) marsha.Decoder {
	panic(marsha.ErrUnimplemented)
}
